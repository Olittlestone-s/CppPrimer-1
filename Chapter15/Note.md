* Object-Oriented基于三个概念：数据抽象、继承和动态绑定
* 只需要在声明时使用`virtual`，定义时不需要
* base class中声明为`virtual`的成员函数在派生类中是隐含`implict`的
* public继承也称为接口继承
* 新标准允许子类在override继承的virtual function时增加`override`关键字表明这是一个重写的函数
* 里氏替换原则：在使用基类的地方都可以使用子类
* 每个类的构造函数只能控制当前类的对象如何构造，对于子类，需要将部分工作委托给基类的构造器
* 继承声明与类定义在一起，而不是与类声明在一起
* 将类声明为`final`表明类不能被继承
* 使用override声明能够帮助在编译时就检查是否成功override一个基类的版本
* 一个变量的静态类型可能与它的动态类型不符合
* 普通成员函数如果不会被使用，甚至可以不定义；但是虚函数无论是否使用，都必须提供定义，否则类无法实例化
* 与继承相关的几个事实：
    1. 隐式类型转换只适用于指针（包括智能指针）和引用
    2. 基类不能隐式转为派生类
    3. 根据继承方式(public/protected/private)的不同，向上转型可能无法访问基类成员!
* 通过对象调用虚函数，绑定发生在编译时；通过指针或引用调用虚函数，发生在运行时

|调用方式\virtual?|是|否|
|---|---|---|
|对象|编译时|编译时|
|基类引用/指针|运行时|编译时|

* override virtual函数时，参数类型必须完全一致，返回类型可以有继承关系（Java里称为协变返回类型）
* final修饰的member function不能被override
* 如果virtual function有默认值，override版本使用的是基类版本的默认值
* 虚函数只有通过引用或指针才会发生动态绑定！
* 通过域操作符显式指定要调用的虚函数（避免动态绑定，比如在子类中调用父类的函数）
* 将虚函数的函数体设置为`= 0`可以将函数声明为“纯虚函数”，拥有纯虚函数的类称为抽象类，抽象类不能被实例化！
* 纯虚函数可有函数体，但必须在类外定义！
* 继承到的protected成员对friend不可见！
* friend关系不可被继承！
* 在子类中可以使用`using`声明保留继承所得到成员的访问级别
* class默认private继承；struct默认public继承
* 继承使子类的class scope“嵌套”在父类的class scope中，name lookup发生在编译时
* 子类会隐藏父类中声明的同名成员，子类应该避免成员隐藏！
* destructor应该是virtual的，否则delete basePtr时，如果basePtr的静态类型与动态类型不符，那么就无法正确执行适当的destructor